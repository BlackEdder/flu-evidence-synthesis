---
title: "Adapting the epidemiological model."
author: "Edwin van Leeuwen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Adapting the epidemiological model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = F}
chooseCRANmirror(ind = 1)
```

# Introduction

This vignette shows how to re-implement the SEEIIR model used in the package using the `odin` ODE solver package. This should show you how to implement your own model or make changes to the current model. The model is currently implemented with the function `infectionODEs` and is called as follows:
```{r, eval=F}
infectionODEs(population, initial_infected, vaccine_calendar, contact_matrix,
  susceptibility, transmissibility, infection_delays, interval)
```
For more details see the [modelling vignette](https://blackedder.github.io/flu-evidence-synthesis/modelling.html).

```{r install, cache = T, echo = F}
if (!require("devtools")) {
  install.packages("devtools")
  library("devtools")
}
if (!require("odin")) {
  devtools::install_github("richfitz/odin")
  library(odin)
}
if (!require("dplyr")) {
  install.packages("dplyr")
  library("dplyr")
}
if (!require("tidyr")) {
  install.packages("tidyr")
  library("tidyr")
}
```

```{r infection_odin, dependson = "model_definition", cache = TRUE}
infection_odin <- function(pop, init_pop, cal, cij, susc, trans, lat, interval) {
  
  begin_date <- as.Date(paste0(format(cal$dates[1], "%Y"),"-09-01"))
  t <- as.numeric(seq(begin_date, begin_date + 7*52, interval))
  
  no_groups <- length(pop)
  no_risk_groups <- no_groups/nrow(cij)
  no_age_groups <- no_groups/no_risk_groups
  
  # Contacts matrix only covers one set of age groups, here we "repeat" it to also cover 
  # risk groups
  new_cij <- matrix(rep(0,no_groups*no_groups), nrow = no_groups)
  for (k in 1:no_risk_groups) {
    for (l in 1:no_risk_groups) {
      lk <- (k - 1)*no_age_groups + 1
      ll <- (l - 1)*no_age_groups + 1
      new_cij[lk:(lk + no_age_groups - 1), ll:(ll + no_age_groups - 1)] <- cij
    }
  }
  
  calendar <- cal$calendar[c(nrow(cal$calendar),1:nrow(cal$calendar)),]
  dates <- as.numeric(c(t[1], cal$dates))
             
  
  # Set the parameter values
  mod <- gen_seeiir_ag_vacc(no_groups = no_groups, cij = new_cij, trans = trans,
                       pop = pop,
                       I0 = init_pop,
                       susc = rep(susc,no_risk_groups),
                       alpha = cal$efficacy[1:no_groups],
                       dates = dates,
                       calendar = calendar[,1:no_groups],
                       gamma1 = 2/lat[1], gamma2 = 2/lat[2])
  y <- mod$run(t, hmax = NULL, method = "euler", hini = 0.25, atol = 1)
  
  # Only return new infections by week, ignore the rest
  y <- y[, (ncol(y) - no_groups + 1):ncol(y)]
  
  # Returning the differences in cumulative infections from one week to the other
  y <- data.frame(y[2:(nrow(y)), ] - y[1:(nrow(y) - 1), ])
  
  #Cleanup and add Time column
  colnames(y) <- sapply(seq(1,no_risk_groups), function(i) sapply(seq(1,no_age_groups), function(j) paste0("Age", i, "Risk", j)))
  mutate(y, Time = as.Date(t[1:nrow(y)], origin = "1970-01-01"))
}
```

```{r model_definition, dependson = "install", cache = T}
gen_seeiir_ag_vacc <- odin::odin({
  # Number of groups
  no_groups <- user()
  
  # Transmissibility
  trans <- user()
  
  # Population size by age/risk group
  pop[] <- user()
  # Initial infection by age/risk group
  I0[] <- user()
  # Susceptibility
  susc[] <- user()
  
  # Latent periods
  gamma1 <- user()
  gamma2 <- user()
  
  # Vaccine related variables 
  dates[] <- user()
  calendar[,] <- user()
  
  # efficacy
  alpha[] <- user()
  
  # Contact matrix
  cij[,] <- user()
   
  # Force of infection
  lambda[] <- trans * susc[i] * (sum(sij[i,]))
   
  # Vaccination
  vI[] <- interpolate(dates, calendar, "constant")
  # Vaccination is given as a fraction vaccination, here we scale it to 
  # a rate
  sumN[] <- if (vI[i]>0) (S[i]+E1[i]+E2[i]+I1[i]+I2[i]+R[i]) else 0
  v[] <- if (sumN[i]>0) vI[i]*pop[i]/sumN[i] else 0
 
  # Transmission matrix
  sij[,] <- cij[i,j] * (I1[j] + I2[j] + I1v[j] + I2v[j])

  # Newly infected
  newInf[] <- lambda[i] * S[i]
  newInfv[] <- lambda[i] * Sv[i]
 
  # Derivatives 
  deriv(S[]) <- -newInf[i] - v[i] * S[i]
  deriv(E1[]) <- newInf[i] - gamma1 * E1[i] - v[i] * E1[i]
  deriv(E2[]) <- gamma1 * (E1[i] - E2[i]) - v[i] * E2[i]
  deriv(I1[]) <- gamma1 * E2[i]  - gamma2 * I1[i] - v[i] * I1[i]
  deriv(I2[]) <- gamma2 * (I1[i] - I2[i]) - v[i] * I2[i]
  deriv(R[]) <- gamma2 * I2[i] - v[i] * R[i]
  
  # Derivatives vaccination group
  deriv(Sv[]) <- -newInfv[i] + v[i] * (1-alpha[i]) * S[i]
  deriv(E1v[]) <- newInfv[i] - gamma1 * E1v[i] + v[i] * E1[i]
  deriv(E2v[]) <- gamma1 * (E1v[i] - E2v[i]) + v[i] * E2[i]
  deriv(I1v[]) <- gamma1 * E2v[i]  - gamma2 * I1v[i] + v[i] * I1[i]
  deriv(I2v[]) <- gamma2 * (I1v[i] - I2v[i]) + v[i] * I2[i]
  deriv(Rv[]) <- gamma2 * I2v[i] + v[i] * (R[i] + alpha[i] * S[i])
   
  # Tracking the cumulative amount of infections over time
  deriv(cumI[]) <- newInf[i] + newInfv[i]
 
  # Initial value of parameters 
  initial(S[1:no_groups]) <- pop[i] - I0[i]
  initial(E1[1:no_groups]) <- 0
  initial(E2[1:no_groups]) <- 0
  initial(I1[1:no_groups]) <- I0[i]
  initial(I2[1:no_groups]) <- 0
  initial(R[1:no_groups]) <- 0
  initial(cumI[1:no_groups]) <- 0
  
  initial(Sv[1:no_groups]) <- 0
  initial(E1v[1:no_groups]) <- 0
  initial(E2v[1:no_groups]) <- 0
  initial(I1v[1:no_groups]) <- 0
  initial(I2v[1:no_groups]) <- 0
  initial(Rv[1:no_groups]) <- 0
 
 
  # Set dimension of all variables 
  dim(dates) <- user()
  dim(calendar) <- user()
  
  dim(pop) <- no_groups
  dim(I0) <- no_groups
  dim(susc) <- no_groups
  dim(lambda) <- no_groups
  dim(v) <- no_groups
  dim(vI) <- no_groups
  dim(sumN) <- no_groups  
  dim(alpha) <- no_groups
  dim(cij) <- c(no_groups, no_groups)
  dim(sij) <- c(no_groups, no_groups)
 
  dim(S) <- no_groups
  dim(E1) <- no_groups
  dim(E2) <- no_groups
  dim(I1) <- no_groups
  dim(I2) <- no_groups
  dim(R) <- no_groups
  dim(Sv) <- no_groups
  dim(E1v) <- no_groups
  dim(E2v) <- no_groups
  dim(I1v) <- no_groups
  dim(I2v) <- no_groups
  dim(Rv) <- no_groups
  dim(cumI) <- no_groups
  dim(newInf) <- no_groups
  dim(newInfv) <- no_groups
})
```


# Run the model

Setup of the demographic and vaccination data. For further details see the [modelling vignette](http://blackedder.github.io/flu-evidence-synthesis/modelling.html)

```{r setup_data, cache = TRUE}
library(fluEvidenceSynthesis)
data(age_sizes)
ag <- stratify_by_age(age_sizes$V1, limits = c(65))

population <- stratify_by_risk(ag, matrix(c(0.01, 0.4), nrow = 1))

ag <- c(1000, 1000)
initial.infected <- stratify_by_risk(ag, matrix(c(0.01, 0.4), nrow = 1))

vaccine_calendar <- as.vaccination.calendar(
  efficacy = c(0.7, 0.3),
  coverage = as.data.frame(matrix(c(0, 0, 0, 0, 0, 0.861, 0.123, 0.861), nrow = 2, byrow = TRUE)),
  dates = c(as.Date("2010-10-01"), as.Date("2011-02-01")),
  no_age_groups = 2,
  no_risk_groups = 2
)

data(polymod_uk)
data(age_sizes)
poly <- polymod_uk[, c(1, 2, 3, 9)]
poly[,3] <- rowSums(polymod_uk[, 3:8])

contacts <- contact.matrix(as.matrix(poly), age_sizes$V1, c(65))
```

Here we actually run and plot the model using the newly defined infection_odin function. Note the differences in the y axis scale. The low risk age group below 65 (`Age1Risk1`) has the largest population and also the largest incidence level.

```{r run_example, dependson=c("infection_odin","setup_data"), cache = TRUE, fig.width=6, fig.height=7}
library(ggplot2)
odes <- infection_odin(population, initial.infected, vaccine_calendar, contacts, 
               c(0.7, 0.3), 0.17, c(0.8, 1.8), 7)

ggplot(data = odes %>% gather(Group, Infections, -Time)) + 
  geom_line(aes(x = Time, y = Infections)) + facet_wrap(~Group,scales = "free")
```

# Further reading

The next step now is to use your new model in the parameter inference. How to do this is explained in more detail in the [inference vignette](https://blackedder.github.io/flu-evidence-synthesis/inference.html).
